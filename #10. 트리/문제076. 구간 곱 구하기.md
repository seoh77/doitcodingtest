# 문제 076. 구간 곱 구하기

![문제076](./img/문제076_구간곱구하기.png)

### 풀이 과정

1. 1차원 배열로 트리의 값을 초기화한다.  
   트리 배열 크기가 N = 5 이므로 $2^k >= N$ 을 만족하는 k의 값은 3이고, 배열의 크기는 $2^3 * 2 = 16$이 된다. 시작 인덱스는 $2^3$ = start_index = 8이다.  
   곱셈이기 때문에 초깃값을 1로 저장해주고, 부모 노드를 양쪽 자식 노드의 곱으로 표현한다. 이때 MOD 연산을 지속적으로 수행해 값의 범위가 1,000,000,007을 넘지 않도록 구현한다.
2. 질의값 연산 함수와 데이터 업데이트 함수를 수행하고 결괏값을 출력한다.  
   이때 값을 업데이트하거나 구간 곱을 구하는 각 곱셈마다 모두 MOD 연산을 수행한다.

   ```
   곱셈과 관련된 % 연산의 성질
   (A _ B) % C = (A % C) _ (B % C) % C
   ```

### 문제집 풀이

```java
메모리 89152KB, 시간 668ms

public class P11505_구간곱구하기 {

	static long[] tree;
	static int MOD;

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		int N = Integer.parseInt(st.nextToken());		// 수의 개수
		int M = Integer.parseInt(st.nextToken());		// 변경이 일어나는 횟수
		int K = Integer.parseInt(st.nextToken());		// 구간 곱을 구하는 횟수

		int treeHeight = 0;
		int length = N;

		while(length != 0) {
			length /= 2;
			treeHeight++;
		}

		int treeSize = (int) Math.pow(2, treeHeight + 1);
		int leftNodeStartIndex = treeSize / 2 - 1;
		MOD = 1000000007;
		tree = new long [treeSize + 1];
		for(int i=0; i<tree.length; i++) {		// 곱셈이므로 초기값을 1로 설정
			tree[i] = 1;
		}

		for(int i = leftNodeStartIndex + 1; i <= leftNodeStartIndex + N; i++) {
			tree[i] = Long.parseLong(br.readLine());	// 데이터를 리프 노드에 입력받기
		}

		setTree(treeSize - 1);		// tree 만들기

		for(int i = 0; i < M + K; i++) {
			st = new StringTokenizer(br.readLine());
			int a = Integer.parseInt(st.nextToken());
			int s = Integer.parseInt(st.nextToken());
			long e = Long.parseLong(st.nextToken());

			if(a == 1) {
				changeVal(leftNodeStartIndex + s, e);
			} else if (a == 2) {
				s = s + leftNodeStartIndex;
				e = e + leftNodeStartIndex;
				System.out.println(getMul(s, (int) e));
			} else {
				return;
			}
		}
	}

	// 모든 함수에서 곱셈이 발생할 때마다 MOD 연산 수행하기

	private static long getMul(int s, int e) {
		long partMul = 1;

		while (s <= e) {
			if (s % 2 == 1) {
				partMul = partMul * tree[s] % MOD;
				s++;
			}

			if( e % 2 == 0) {
				partMul = partMul * tree[e] % MOD;
				e--;
			}

			s = s/2;
			e = e/2;
		}

		return partMul;
	}

	private static void changeVal(int index, long val) {
		tree[index] = val;

		while(index > 1) {		// 현재 노드의 양쪽 자식 노드를 찾아 곱하는 로직
			index = index / 2;
			tree[index] = tree[index * 2] % MOD * tree[index * 2 + 1] % MOD;
		}
	}

	private static void setTree(int i) {
		while (i != 1) {
			tree[i/2] = tree[i/2] * tree[i] % MOD;
			i--;
		}
	}
}
```
