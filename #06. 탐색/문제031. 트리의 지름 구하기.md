# 문제 031. 트리의 지름 구하기

![문제031](./img/문제031_트리의지름구하기.png)

### 아이디어

- 임의의 노드에서 가장 긴 경로로 연결돼 있는 노드는 트리의 지름에 해당하는 두 노드 중 하나이다.

### 풀이 순서

1. 그래프를 인접 리스트로 저장한다. 이때 (노드, 가중치)를 표현하기 위해서 노드는 클래스로 선언
2. 임의의 노드에서 BFS를 수행하고 탐색할 때 각 노드의 거리를 배열에 저장
3. 과정2에서 얻은 배열에서 임의의 노드와 가장 먼 노드를 찾는다. 이후 그 노드부터 다시 BFS를 수행하며 마찬가지로 탐색할 때 각 노드의 거리를 배열에 저장
4. 과정3에서 배열에 저장한 값 중 가장 큰 값을 이 트리의 지름으로 출력

### 문제집 풀이

```java
메모리 332144KB, 시간 1792ms

class Edge {
	int e;
	int value;

	public Edge(int e, int value) {
		this.e = e;
		this.value = value;
	}
}

public class P1167_트리의지름 {

	static boolean[] visited;
	static int[] distance;
	static ArrayList<Edge>[] A;

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();		// 노드 개수
		A = new ArrayList[N+1];
		for(int i=1; i<=N; i++) {
			A[i] = new ArrayList<Edge>();
		}

		// A 인접 리스트에 그래프 데이터 저장
		for(int i=0; i<N; i++) {
			int S = sc.nextInt();
			while(true) {
				int E = sc.nextInt();
				if(E == -1) {
					break;
				}

				int V = sc.nextInt();
				A[S].add(new Edge(E, V));
			}
		}

		distance = new int [N+1];
		visited = new boolean [N+1];
		BFS(1);

		int max = 1;

		// distance 배열에서 가장 큰 값으로 다시 시작점 설정
		for(int i=2; i<=N; i++) {
			if(distance[max] < distance[i]) {
				max = i;
			}
		}

		distance = new int [N+1];
		visited = new boolean [N+1];
		BFS(max);	// 새로운 시작점으로 실행

		Arrays.sort(distance);
		System.out.println(distance[N]);
	}

	private static void BFS(int index) {
		Queue<Integer> queue = new LinkedList<Integer>();
		queue.add(index);
		visited[index] = true;

		while(!queue.isEmpty()) {
			int now_node = queue.poll();
			for(Edge i : A[now_node]) {
				int e = i.e;
				int v = i.value;

				if(!visited[e]) {
					visited[e] = true;
					queue.add(e);
					distance[e] = distance[now_node] + v;	// 거리 배열 업데이트
				}
			}
		}
	}
}
```
