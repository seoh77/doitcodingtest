# 문제 025. 친구 관계 파악하기

![문제025](./img/문제025_친구관계파악하기.png)

### 내가 작성한 풀이 (오답)

```java
시간초과

public class P13023_친구관계파악하기 {

	static int[][] arr;
	static boolean[] visited;
	static boolean result;

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st;

		st = new StringTokenizer(br.readLine());
		int N = Integer.parseInt(st.nextToken());	// 사람의 수
		int M = Integer.parseInt(st.nextToken());	// 친구 관계의 수

		arr = new int [N][N];	// 친구 관계를 연결하는 배열
		for(int i=0; i<M; i++) {
			st = new StringTokenizer(br.readLine());
			int a = Integer.parseInt(st.nextToken());
			int b = Integer.parseInt(st.nextToken());

			// a와 b가 친구
			arr[a][b] = arr[b][a] = 1;
		}

		visited = new boolean [N];
		result = false;

		for(int i=0; i<N; i++) {
			// 이미 결과를 구했다면 pass
			if(result) {
				break;
			}

			dfs(i, 1);
		}

		System.out.println(result ? 1 : 0);
	}

	private static void dfs(int idx, int count) {
		// 친구 5명이 연결된 경우 문제에서 주어진 친구 관계가 존재한다고 판단 후 종료
		if(count == 5) {
			result = true;
			return;
		}

		visited[idx] = true;

		for(int i=0; i<arr[idx].length; i++) {
			// 이미 방문한 적이 있거나 친구 관계가 아니라면 pass
			if(visited[i] || arr[idx][i] == 0) {
				continue;
			}

			dfs(i, count+1);
		}

		visited[idx] = false;
	}
}
```

### 문제집 풀이

```java
메모리 42512KB, 시간 448ms

public class P13023_친구관계파악하기 {

	static boolean[] visited;
	static ArrayList<Integer>[] A;
	static boolean arrive;

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();	// 노드 개수
		int M = sc.nextInt();		// 에지 개수

		A = new ArrayList[N];
		for(int i=0; i<N; i++) {
			A[i] = new ArrayList<Integer>();
		}

		for(int i=0; i<M; i++) {
			int S = sc.nextInt();
			int E = sc.nextInt();
			A[S].add(E);
			A[E].add(S);
		}

		visited = new boolean [N];
		arrive = false;
		for(int i=0; i<N; i++) {
			DFS(i, 1);		// depth 1부터 시작

			if(arrive) {
				break;
			}
		}

		if(arrive) {
			System.out.println("1");
		} else {
			System.out.println("0");	// 5의 깊이가 없다면 0 출력
		}
	}

	private static void DFS(int now, int depth) {
		if(depth == 5 || arrive) {		// depth가 5가 되면 프로그램 종료
			arrive = true;
			return;
		}

		visited[now] = true;

		for(int i : A[now]) {
			if(!visited[i]) {
				DFS(i, depth + 1);		// 재귀 호출이 될 때마다 depth를 1씩 증가
			}
		}

		visited[now] = false;
	}
}
```
