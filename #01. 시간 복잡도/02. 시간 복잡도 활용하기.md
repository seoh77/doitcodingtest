# 01-2. 시간 복잡도 활용하기

### 1. 알고리즘 선택의 기준으로 사용하기

#### 문제 000. 수 정렬하기

```
N개의 수가 주어졌을 때 이를 오름차순 정렬하는 프로그램을 작성하시오. (시간 제한 2초)

[ 입력 ]
1번째 줄에 수의 개수 N(1 <= N <= 1,000,000), 2번째 줄부터는 N개의 줄에 숫자가 주어진다.
이 수는 절댓값이 1,000,000보다 작거나 같은 정수다. 수는 중복되지 않는다.

[ 출력 ]
1번째 줄부터 N개의 줄에 오름차순 정렬한 결과를 1줄에 1개씩 출력한다.
```

- 연산 횟수는 1초에 1억 번 연산하는 것을 기준으로 생각한다.

  → 시간 제한이 2초이므로 이 조건을 만족하려면 2억 번 이하의 연산 횟수로 문제를 해결해야 한다.

- 연산 횟수 계산 방법 = 알고리즘 시간 복잡도 n 값에 데이터의 최대 크기를 대입하여 도출

- 알고리즘 적합성 평가

  - 버블 정렬의 시간 복잡도 : $O(n^2)$

    → $(1,000,000)^2$ = 1,000,000,000,000 < 200,000,000 : 부적합 알고리즘

  - 병합 정렬의 시간 복잡도 : $O(nlogn)$

    → $1,000,000 log (1,000,000)$ = 약 20,000,000 < 200,000,000 : 적합 알고리즘

<br />

### 2. 시간 복잡도를 바탕으로 코드 로직 개선하기

#### 시간 복잡도 도출 기준

1. 상수는 시간 복잡도 계산에서 제외한다.
2. 가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도의 기준이 된다.

<br />

```java
예제1. 연산 횟수 = N

public class 시간복잡도_판별원리1 {

    public static void main(String[] args) {
        int N = 100000;
        int cnt = 0;

        for(int i=0; i<N; i++) {
            System.out.println("연산 횟수: " + cnt++);
        }
    }
}
```

```java
예제2. 연산 횟수 = 3N

public class 시간복잡도_판별원리2 {

	public static void main(String[] args) {
		int N = 100000;
		int cnt = 0;

		for(int i=0; i<N; i++) {
			System.out.println("연산 횟수: " + cnt++);
		}

		for(int i=0; i<N; i++) {
			System.out.println("연산 횟수: " + cnt++);
		}

		for(int i=0; i<N; i++) {
			System.out.println("연산 횟수: " + cnt++);
		}
	}
}

```

- 두 예제 코드의 연산 횟수는 3배의 차이가 난다. 하지만 코딩 테스트에서는 일반적으로 상수를 무시하므로 두 코드 모두 시간 복잡도는 O(n)으로 같다.

<br />

```java
예제3. 연산 횟수 = N^2

public class 시간복잡도_판별원리3 {

	public static void main(String[] args) {
		int N = 100000;
		int cnt = 0;

		for(int i=0; i<N; i++) {
			for(int j=0; j<N; j++) {
				System.out.println("연산 횟수: " + cnt++);
			}
		}
	}
}
```

- 시간 복잡도는 가장 많이 중첩된 반복문을 기준으로 도출하므로 이 코드에서는 이중 for문이 전체 코드의 시간 복잡도 기준이 된다.
- 만약 일반 for문이 10개 더 있다 하더라도 도출 원리 기준에 따라 시간 복잡도는 변화 없이 $N^2$으로 유지된다.
