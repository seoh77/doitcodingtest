# 문제 064. 가장 빠른 버스 노선 구하기

![문제064](./img/문제064_가장빠른버스노선구하기.png)

### 내가 작성한 풀이

- 충분히 큰 값을 설정하는 부분에서 어려움을 겪음..
- `Integer.MAX_VALUE` 로 설정하면 플로이드-워셜 부분에서 값을 더할 때 int 범위를 초과해서 오류 발생
- 버스 최대 비용인 100,000 보다 큰 100,001로 설정하면 환승해서 비용이 100,001을 초과하는 값이 생길 수도 있음
- 따라서, 버스 최대 비용인 100,000와 도시 개수를 곱해서 충분히 큰 값을 만들어줌

```java
메모리 45076KB, 시간 400ms

public class P11404_플로이드 {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		StringTokenizer st;

		int n = Integer.parseInt(br.readLine());	// 도시의 개수
		int m = Integer.parseInt(br.readLine());	// 버스의 개수
		int INF = 100000 * n + 1;		// 충분히 큰 값 = 최대 비용인 100,000 * 도시의 개수 + 1

		int[][] minCostArr = new int [n+1][n+1];	// 최소 비용을 관리하는 배열
		for(int i=1; i<=n; i++) {
			for(int j=1; j<=n; j++) {
				// 자기 자신은 0, 그 외는 최댓값으로 비용 세팅
				if(i == j) {
					minCostArr[i][j] = 0;
				} else {
					minCostArr[i][j] = INF;
				}
			}
		}
		// 버스 연결
		for(int i=0; i<m; i++) {
			st = new StringTokenizer(br.readLine());
			int a = Integer.parseInt(st.nextToken());	// 버스 시작 도시
			int b = Integer.parseInt(st.nextToken());	// 버스 도착 도시
			int c = Integer.parseInt(st.nextToken());	// 한 번 타는데 필요한 비용
			minCostArr[a][b] = Math.min(minCostArr[a][b], c);
		}

		// 플로이드-워셜
		for(int k=1; k<=n; k++) {
			for(int s=1; s<=n; s++) {
				for(int e=1; e<=n; e++) {
					minCostArr[s][e] = Math.min(minCostArr[s][e], minCostArr[s][k] + minCostArr[k][e]);
				}
			}
		}

		// 출력
		for(int i=1; i<=n; i++) {
			for(int j=1; j<=n; j++) {
				if(minCostArr[i][j] == INF) {
					bw.append(0 + " ");
				} else {
					bw.append(minCostArr[i][j] + " ");
				}
			}
			bw.append("\n");
		}

		bw.flush();
		bw.close();
	}
}
```

### 문제집 풀이

```java
메모리 45604KB, 시간 440ms

public class P11404_플로이드 {

	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

	public static void main(String[] args) throws IOException {
		int N = Integer.parseInt(br.readLine());
		int M = Integer.parseInt(br.readLine());

		int[][] distance = new int [N+1][N+1];
		for(int i=1; i<=N; i++) {		// 인접 행렬 초기화하기
			for(int j=1; j<=N; j++) {
				if(i == j) {
					distance[i][j] = 0;
				} else {
					distance[i][j] = 10000001;	// 충분히 큰 수로 저장
				}
			}
		}

		for(int i=0; i<M; i++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int s = Integer.parseInt(st.nextToken());
			int e = Integer.parseInt(st.nextToken());
			int v = Integer.parseInt(st.nextToken());
			if(distance[s][e] > v) {
				distance[s][e] = v;
			}
		}

		for(int k=1; k<=N; k++) {
			for(int i=1; i<=N; i++) {
				for(int j=1; j<=N; j++) {
					if(distance[i][j] > distance[i][k] + distance[k][j]) {
						distance[i][j] = distance[i][k] + distance[k][j];
					}
				}
			}
		}

		for(int i=1; i<=N; i++) {
			for(int j=1; j<=N; j++) {
				if(distance[i][j] == 10000001) {
					System.out.print("0 ");
				} else {
					System.out.print(distance[i][j] + " ");
				}
			}
			System.out.println();
		}
	}
}
```
