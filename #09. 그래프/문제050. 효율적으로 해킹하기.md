# 문제 050. 효율적으로 해킹하기

![문제050](./img/문제050_효율적인해킹.png)

### 내가 작성한 풀이 (오답)

- 그냥 BFS로 풀이를 하면 시간초과가 발생해서 신뢰하는 컴퓨터가 없는 컴퓨터만을 시작점으로 잡으면 더 빠르게 수행할 수 있을 것이라고 기대
- 하지만 사이클이 생기는 경우 어느 것도 탐색하지 못하고 그대로 종료되어 오답이 발생함
- 그러면 어떻게 시간 초과를 해결해야 할 지 모르겠다..

```java

public class P1325_효율적인해킹 {

	static int N;		// N개의 컴퓨터
	static ArrayList<Integer>[] adj;	// 인접리스트

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());

		N = Integer.parseInt(st.nextToken());
		int M = Integer.parseInt(st.nextToken());	// 신뢰하는 관계 수

		boolean[] isStart = new boolean [N+1];			// 신뢰하는 컴퓨터가 없는 곳부터 시작하기 위해 신뢰하는 컴퓨터가 없는 값을 체크
		for(int i=1; i<=N; i++) {
			isStart[i] = true;
		}

		adj = new ArrayList [N+1];	// 인접리스트
		for(int i=1; i<=N; i++) {
			adj[i] = new ArrayList<Integer>();		// 인접리스트 값 초기화
		}

		for(int i=0; i<M; i++) {
			st = new StringTokenizer(br.readLine());
			int A = Integer.parseInt(st.nextToken());
			int B = Integer.parseInt(st.nextToken());

			// A가 B를 신뢰한다 = B를 해킹하면 A도 해킹할 수 있다.
			adj[B].add(A);

			// A에서는 시작하지 않아도 됨
			isStart[A] = false;
		}

		int max = 0;		// 한 번에 가장 많이 컴퓨터를 해킹했을 때 컴퓨터의 수
		List<Integer> answerList = new ArrayList<Integer>();	// 한 번에 가장 많은 컴퓨터를 해킹할 수 있는 컴퓨터의 번호

		// 시작할 수 있는 지점부터 해킹할 수 있는 컴퓨터 수 세기
		for(int i=1; i<=N; i++) {
			if(!isStart[i]) {
				continue;
			}

			int totalHacking = countHacking(i);	// i 컴퓨터를 해킹했을 때 해킹할 수 있는 컴퓨터 수 세기

			// 기존의 max 값보다 크다면 기존 answerList를 지우고 새로 생성
			if (totalHacking > max) {
				max = totalHacking;
				answerList = new ArrayList<Integer>();
				answerList.add(i);
			} else if (totalHacking == max) {	// 기존 max 값과 같다면 answerList에 i 값을 추가
				answerList.add(i);
			}
		}

		// 정답출력
		Collections.sort(answerList);	// 오름차순 정렬
		for(int answer : answerList) {
			System.out.print(answer + " ");
		}
	}

	/**
	 * start 컴퓨터를 해킹했을 때 해킹할 수 있는 컴퓨터 수를 BFS로 계산
	 */
	private static int countHacking(int start) {
		Queue<Integer> queue = new LinkedList<Integer>();
		boolean[] visited = new boolean [N+1];

		queue.add(start);
		visited[start] = true;
		int totalHacking = 0;

		while(!queue.isEmpty()) {
			int now = queue.poll();
			totalHacking++;

			for(int next : adj[now]) {
				if(visited[next]) {
					continue;
				}

				visited[next] = true;
				queue.add(next);
			}
		}

		return totalHacking;
	}
}
```

### 문제집 풀이

```java
메모리 306356KB, 시간 10860ms

public class P1325_효율적인해킹 {

	static int N, M;
	static boolean[] visited;
	static int[] answer;
	static ArrayList<Integer>[] A;

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		N = Integer.parseInt(st.nextToken());
		M = Integer.parseInt(st.nextToken());

		A = new ArrayList [N+1];
		answer = new int [N+1];
		for(int i=1; i<=N; i++) {
			A[i] = new ArrayList<Integer>();
		}

		for(int i=0; i<M; i++) {
			st = new StringTokenizer(br.readLine());
			int S = Integer.parseInt(st.nextToken());
			int E = Integer.parseInt(st.nextToken());

			A[S].add(E);
		}

		// 모든 노드로 BFS 실행
		for(int i=1; i<=N; i++) {
			visited = new boolean [N+1];
			BFS(i);
		}

		int maxVal = 0;
		for(int i=1; i<=N; i++) {
			maxVal = Math.max(maxVal, answer[i]);
		}

		for(int i=1; i<=N; i++) {
			if(answer[i] == maxVal) {		// answer 배열에서 maxVal과 같은 값을 지닌 index가 정답
				System.out.print(i + " ");
			}
		}
	}

	private static void BFS(int index) {
		Queue<Integer> queue = new LinkedList<Integer>();

		queue.add(index);
		visited[index] = true;

		while(!queue.isEmpty()) {
			int nowNode = queue.poll();

			for(int i : A[nowNode]) {
				if(visited[i]) {
					continue;
				}

				visited[i] = true;
				answer[i]++;	// 신규 노드 인덱스의 정답 배열 값을 증가시키기
				queue.add(i);
			}
		}
	}
}
```
