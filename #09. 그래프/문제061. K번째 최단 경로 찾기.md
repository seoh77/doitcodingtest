# 문제 061. K번째 최단 경로 찾기

![문제061](./img/문제061_K번째최단경로찾기.png)

### 문제 분석

- 최단 경로를 표현하는 배열을 우선순위 큐 배열(크기는 K)로 변경하여, 최단 경로뿐 아니라 최단 경로부터 K번째 최단 경로까지 표현
- K번째 경로를 찾기 위해서는 노드를 여러 번 사용하는 경우도 생기기 때문에, 사용한 노드를 방문 배열에 체크해 두고 이후에 재사용하지 않는 부분은 삭제

<br />

**최단 거리 배열 채우기 규칙**

1. 현재 노드에 저장된 경로가 K개 미만일 때 신규 경로를 추가
2. 경로가 K개일 때 현재 경로 중 최대 경로와 신규 경로를 비교해 신규 경로가 더 작을 때 업데이트한다.  
   → 우선순위 큐를 사용하면 이 로직을 쉽게 구현 가능
3. K번째 경로를 찾기 위해서는 노드를 여러 번 쓰는 경우가 생기므로 사용한 노드는 방문 배열에 확인해 두고 재사용하지 않는 부분은 삭제

<br />

### 문제집 풀이

```java
메모리 92272KB, 시간 1296ms

class Node implements Comparable<Node>{
	int node;
	int cost;

	Node(int node, int cost) {
		this.node = node;
		this.cost = cost;
	}

	@Override
	public int compareTo(Node o) {
		return this.cost < o.cost ? -1 : 1;
	}
}

public class P1854_K번째최단경로찾기 {

	static final int INF = 100000000;

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

		StringTokenizer st = new StringTokenizer(br.readLine());
		int n = Integer.parseInt(st.nextToken());		// 도시 개수
		int m = Integer.parseInt(st.nextToken());		// 도로 개수
		int k = Integer.parseInt(st.nextToken());		// k번째 최단경로

		PriorityQueue<Integer>[] distQueue = new PriorityQueue [n+1];
		Comparator<Integer> cp = new Comparator<Integer>() {
			@Override
			public int compare(Integer o1, Integer o2) {
				return o1 < o2 ? 1 : -1;	 // 오름차순 정렬 기준 설정
			}
		};
		for(int i=0; i<n+1; i++) {
			distQueue[i] = new PriorityQueue<Integer>(k, cp);
		}

		// 도로 연결
		int[][] W = new int [1001][1001];
		for(int i=0; i<m; i++) {
			st = new StringTokenizer(br.readLine());
			int a = Integer.parseInt(st.nextToken());
			int b = Integer.parseInt(st.nextToken());
			int c = Integer.parseInt(st.nextToken());

			W[a][b] = c;
		}

		// 도착 시간 계산
		PriorityQueue<Node> pq = new PriorityQueue<Node>();
		pq.add(new Node(1, 0));
		distQueue[1].add(0);

		while(!pq.isEmpty()) {
			Node now = pq.poll();

			// 연결된 모든 노드로 검색하기 (시간 복잡도 측면에서 인접 행렬이 불리한 이유)
			for(int adjNode=1; adjNode<=n; adjNode++) {
				if(W[now.node][adjNode] != 0) {
					// 저장된 경로가 K개가 안 될 때는 그냥 추가하기
					if(distQueue[adjNode].size() < k) {
						distQueue[adjNode].add(now.cost + W[now.node][adjNode]);
						pq.add(new Node(adjNode, now.cost + W[now.node][adjNode]));
					}

					// 저장된 경로가 K개이면, 현재 가장 큰 값보다 작을 때만 추가하기
					else if (distQueue[adjNode].peek() > now.cost + W[now.node][adjNode]) {
						distQueue[adjNode].poll();		// 기존 큐에서 Max 값 먼저 삭제
						distQueue[adjNode].add(now.cost + W[now.node][adjNode]);
						pq.add(new Node(adjNode, now.cost + W[now.node][adjNode]));
					}
				}
			}
		}

		// 출력 (k번째 최단경로가 존재하지 않으면 -1 출력)
		for(int i=1; i<=n; i++) {
			if(distQueue[i].size() == k) {
				bw.write(distQueue[i].peek() + "\n");
			} else {
				bw.write(-1 + "\n");
			}
		}

		bw.flush();
		bw.close();
	}
}
```
