# 문제 057. 게임 개발하기

![문제057](./img/문제057_게임개발하기.png)

### 내가 작성한 풀이 (오답)

- 시간이 중복으로 합산되는 부분을 어떻게 처리해야 할 지 모르겠다.

```java
public class P1516_게임개발 {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st;

		int N = Integer.parseInt(br.readLine());	// 건물의 종류 수
		int[] prevNodeCount = new int [N+1];		// 각 노드 건물을 짓기 위해 먼저 지어져야 하는 건물 숫자

		ArrayList<Integer>[] adj = new ArrayList [N+1];		// 각 노드 건물을 짓기 위해 먼저 지어져야 하는 건물들의 번호 관리
		for(int i=1; i<=N; i++) {
			adj[i] = new ArrayList<Integer>();
		}

		int[] timeArr = new int [N+1];		// 각 노드 건물을 짓는데 걸리는 시간을 저장하는 배열

		for(int num=1; num<=N; num++) {
			st = new StringTokenizer(br.readLine());

			int time = Integer.parseInt(st.nextToken());	// 해당 노드 건물을 짓는데 걸리는 시간
			timeArr[num] = time;

			int prevNode = Integer.parseInt(st.nextToken());
			while(prevNode != -1) {
				prevNodeCount[num]++;
				adj[prevNode].add(num);

				prevNode = Integer.parseInt(st.nextToken());
			}
		}

		// 진입차수가 0인 것부터 시작
		Queue<Integer> queue = new LinkedList<Integer>();
		for(int i=1; i<=N; i++) {
			if(prevNodeCount[i] == 0) {
				queue.add(i);
			}
		}

		while(!queue.isEmpty()) {
			int now = queue.poll();		// 현재 건물 번호

			for(int next : adj[now]) {
				timeArr[next] += timeArr[now];		// 시간 합산
				prevNodeCount[next]--;				// 먼저 지어져야 하는 건물의 수 하나 빼기 (지어졌기 때문)

				if(prevNodeCount[next] == 0) {		// 먼저 지어져야 하는 건물이 없다면 queue에 추가
					queue.add(next);
				}
			}
		}

		// 정답 출력
		for(int i=1; i<=N; i++) {
			System.out.println(timeArr[i]);
		}
	}
}
```

### 문제집 풀이

```java
메모리 22380KB, 시간 256ms

public class P1516_게임개발 {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int N = Integer.parseInt(br.readLine());

		ArrayList<ArrayList<Integer>> A = new ArrayList<>();
		for(int i=0; i<=N; i++) {
			A.add(new ArrayList<>());
		}

		int[] indegree = new int [N+1];		// 진입차수 배열
		int[] selfBuild = new int [N+1];	// 자기 자신을 짓는 데 걸리는 시간

		for(int i=1; i<=N; i++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			selfBuild[i] = Integer.parseInt(st.nextToken());	// 자신의 생산 시간 저장하기

			while(true) {		// 인접 리스트 데이터 저장하기
				int preTemp = Integer.parseInt(st.nextToken());
				if(preTemp == -1) {
					break;
				}

				A.get(preTemp).add(i);
				indegree[i]++;		// 진입 차수 배열 데이터 저장하기
			}
		}

		// 위상 정렬
		Queue<Integer> queue = new LinkedList<>();
		for(int i=1; i<=N; i++) {
			if(indegree[i] == 0) {
				queue.offer(i);
			}
		}

		int[] result = new int [N+1];
		while(!queue.isEmpty()) {
			int now = queue.poll();
			for(int next : A.get(now)) {
				indegree[next]--;

				// 시간 업데이트하기
				result[next] = Math.max(result[next], result[now] + selfBuild[now]);
				if(indegree[next] == 0) {
					queue.offer(next);
				}
			}
		}

		for(int i=1; i<=N; i++) {
			System.out.println(result[i] + selfBuild[i]);
		}
	}
}
```
