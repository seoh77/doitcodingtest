# 문제 052. 물의 양 구하기

![문제052](./img/문제052_물의양구하기.png)

### 문제 분석

- 지금까지 풀었던 그래프 데이터를 저장하고 저장한 자료구조를 이용하는 방식과 달리, 그래프 원리를 적용해 그래프를 역으로 그리는 방식으로 접근하는 문제
- A, B, C의 특정 무게 상태를 1개의 노드로 가정하고, 조건에 따라 이 상태에서 변경할 수 있는 이후 무게 상태가 에지로 이어진 인접한 노드라고 생각

### 문제 풀이

1. 처음에 물통 A, B는 비어있고, C는 꽉 차 있으므로 출발 노드를 (0, 0, 3번째 물통의 용량)으로 초기화
2. BFS를 수행
   - 노드에서 갈 수 있는 6가지 경우(A → B, A → C, B → A, B → C, C → A, C → B)에 관해 다음 노드로 정해 큐에 추가한다.  
     A, B, C 무게가 동일한 노드에 방문한 이력이 있을 때는 큐에 추가하지 않는다.
   - 보내는 물통의 모든 용량을 받는 물통에 저장하고, 보내는 물통에는 0을 저장한다.
     단, 받는 물통이 넘칠 때는 초과하는 값만큼 보내는 물통에 남긴다.
   - 큐에 추가하는 시점에 1번째 물통(A)의 무게가 0일 때가 있으면 3번째 물통(C)의 값을 정답 배열에 추가한다.
3. 정답 리스트를 오름차순 출력한다.

### 문제집 풀이

```java
메모리 18368KB, 시간 184ms

// AB 클래스 선언 -> A와 B의 값만 지니고 있으면 C는 유추할 수 있으므로 두 변수만 사용
class AB {
	int A;
	int B;

	public AB(int A, int B) {
		this.A = A;
		this.B = B;
	}
}

public class P2251_물통 {

	// 6가지 이동 케이스를 표현하기 위한 배열
	static int[] sender = {0, 0, 1, 1, 2, 2};
	static int[] receiver = {1, 2, 0, 2, 0, 1};

	static int[] now;
	static boolean[][] visited;		// A, B의 무게가 있으면 C의 무게가 고정되므로 2개만 체크
	static boolean[] answer;

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		now = new int [3];
		now[0] = sc.nextInt();
		now[1] = sc.nextInt();
		now[2] = sc.nextInt();

		visited = new boolean [201][201];
		answer = new boolean [201];

		bfs();

		for(int i=0; i<answer.length; i++) {
			if(answer[i]) {
				System.out.print(i + " ");
			}
		}
	}

	private static void bfs() {
		Queue<AB> queue = new LinkedList<>();
		queue.add(new AB(0, 0));
		visited[0][0] = true;
		answer[now[2]] = true;

		while(!queue.isEmpty()) {
			AB p = queue.poll();
			int A = p.A;
			int B = p.B;
			int C = now[2] - A - B;		// C는 전체 물의 양에서 A와 B를 뺀 것

			// A → B, A → C, B → A, B → C, C → A, C → B
			for(int k=0; k<6; k++) {
				int[] next = {A, B, C};
				next[receiver[k]] += next[sender[k]];
				next[sender[k]] = 0;

				if(next[receiver[k]] > now[receiver[k]]) {		// 물이 넘칠 때
					// 초과하는 만큼 다시 이전 물통에 넣어줌
					next[sender[k]] = next[receiver[k]] - now[receiver[k]];
					next[receiver[k]] = now[receiver[k]];		// 대상 물통은 최대로 채워줌
				}

				if(!visited[next[0]][next[1]]) {	// A와 B의 물의 양을 이용해 방문 배열 체크
					visited[next[0]][next[1]] = true;
					queue.add(new AB(next[0], next[1]));

					if(next[0] == 0) {		// A의 물의 양이 0일 때, C의 물의 양을 정답 변수에 저장
						answer[next[2]] = true;
					}
				}
			}
		}
	}
}
```
