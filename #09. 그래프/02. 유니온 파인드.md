# 09-2. 유니온 파인드

### 유니온 파인드 (union-find)

- 일반적으로 여러 노드가 있을 때, 특정 2개의 노드를 연결해 1개의 집합으로 묶는 union 연산과 두 노드가 같은 집합에 속해 있는지를 확인하는 find 연산으로 구성되어 있는 알고리즘

<br />

### 핵심 이론

- union 연산 : 각 노드가 속한 집합을 1개로 합치는 연산이다.  
  노드 a, b가 `a ∈ A`, `b ∈ B` 일 때 `union(a, b)`는 `A ∪ B`를 말한다.
- find 연산 : 특정 노드 a에 관해 a가 속한 집합의 대표 노드를 반환하는 연산  
  노드 a가 `a ∈ A` 일 때 `find(a)`는 A 집합의 대표 노드를 반환한다.

<br />

### 구현 방법

1. 유니온 파인드를 표현하는 일반적인 방법은 1차원 배열을 이용하는 것이다.  
   처음에는 노드가 연결되어 있지 않으므로 각 노드가 대표 노드가 된다. 각 노드가 모두 대표 노드이므로 배열을 자신의 인덱스 값으로 초기화한다.
2. 2개의 노드를 선택해 각각의 대표 노드를 찾아 연결하는 union 연산을 수행한다.  
   예를 들어 배열 [4]를 1로 업데이트하면 1은 대표 노드, 4는 자식 노드로 union 연산을 하므로 배열 [4]의 대표 노드를 1로 설정한 것이다.  
   다시 말해 자식 노드로 들어가는 노드값 4를 대표 노드값 1로 변경한 것이다. 그 결과 각각의 집합이었던 1, 4는 하나로 합쳐진다.  
   여기서 union(4, 6)을 수행한다면 4는 대표 노드가 아니기 때문에 각 노드의 대표 노드를 찾아 올라간 다음 그 대표 노드를 연결한다.
3. find 연산은 자신이 속한 집합의 대표 노드를 찾는 연산이다.  
   find 연산은 단순히 대표 노드를 찾는 역할만 하는 것이 아니라 그래프를 정돈하고 시간 복잡도를 향상시킨다.

#### find 연산 동작 원리

1. 대상 노드 배열에 index 값과 value 값이 동일한지 확인한다.
2. 동일하지 않으면 value 값이 가리키는 index 위치로 이동한다.
3. 이동 위치의 index 값과 value 값이 같을 때까지 1~2를 반복한다. 반복이므로 이 부분은 재귀 함수로 구현한다.
4. 대표 노드에 도달하면 재귀 함수를 빠져나오면서 거치는 모든 노드값을 루트 노드값으로 변경한다.

→ find 연산은 잘 생각하면 시간 복잡도가 줄어드는 효과를 얻게 된다. 연산을 할 때 거치는 노드들이 대표 노드와 바로 연결되는 형태로 변경되는 것을 알 수 있다. 이렇게 되면 추후 노드와 관련된 find 연산 속도가 O(1)로 변경된다.

<br />

### 예제 문제

- [문제 053. 집합 표현하기]()
- [문제 054. 여행 계획 짜기]()
- [문제 055. 거짓말쟁이가 되긴 싫어]()
