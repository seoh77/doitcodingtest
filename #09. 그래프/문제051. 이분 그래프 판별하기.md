# 문제 051. 이분 그래프 판별하기

![문제051](./img/문제051_이분그래프판별하기.png)

### 이분 그래프 보충 설명

<img src="./img/이분그래프.png" width="600px" />

- 이분그래프란 인접한 정점끼리 서로 다른 색으로 칠해서 모든 정점을 두 가지 색으로만 칠할 수 있는 그래프
- 즉, 서로 인접한 정점이 같은 색이면 이분 그래프가 아니다.

### 내가 작성한 풀이

```java
메모리 273604KB, 시간 880ms

public class P1707_이분그래프 {

	static ArrayList<Integer>[] adj;

	static int[] setNum;
	static String answer;

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

		StringTokenizer st = new StringTokenizer(br.readLine());
		int TC = Integer.parseInt(st.nextToken());		// 테스트 케이스 수

		for(int t=1; t<=TC; t++) {
			st = new StringTokenizer(br.readLine());
			int V = Integer.parseInt(st.nextToken());		// 정점의 개수
			int E = Integer.parseInt(st.nextToken());		// 간선의 개수

			adj = new ArrayList [V+1];		// 인접리스트
			for(int i=0; i<V+1; i++) {
				adj[i] = new ArrayList<Integer>();
			}

			// 간선 연결 (양방향)
			for(int i=0; i<E; i++) {
				st = new StringTokenizer(br.readLine());
				int u = Integer.parseInt(st.nextToken());
				int v = Integer.parseInt(st.nextToken());

				adj[u].add(v);
				adj[v].add(u);
			}

			setNum = new int [V+1];		// 집합 번호 저장 (1, -1, 0은 방문하지 않음)
			answer = "YES";				// 주어진 그래프가 이분 그래프면 YES, 아니면 NO

			for(int i=1; i<=V; i++) {
				// 이미 집합이 결정된 노드는 pass
				if(setNum[i] != 0) {
					continue;
				}

				setNode(i, 1);
			}

			bw.append(answer + "\n");
		}

		bw.flush();
		bw.close();
	}

	/**
	 * DFS를 사용하여 그래프의 정점들을 집합에 분류
	 */
	private static void setNode(int node, int set) {
		setNum[node] = set;

		for(int next : adj[node]) {
			// 다음 노드는 현재 노드와 다른 집합에 들어가야 하는데 이미 set과 같은 집합에 들어갔다면 이분그래프가 될 수 없음
			if(setNum[next] == set) {
				answer = "NO";
				return;
			}

			// 다음 노드를 방문한 적이 있다면 pass
			else if (setNum[next] == -set) {
				continue;
			}

			// 다음 노드를 방문한 적이 없는 경우에만 처리됨
			setNode(next, -set);
		}
	}
}
```

### 문제집 풀이

```java
메모리 308304KB, 시간 992ms

public class P1707_이분그래프 {

	static ArrayList<Integer>[] A;
	static int[] check;
	static boolean[] visited;
	static boolean isEven;

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int N = Integer.parseInt(br.readLine());

		for(int t=0; t<N; t++) {
			String[] s = br.readLine().split(" ");
			int V = Integer.parseInt(s[0]);
			int E = Integer.parseInt(s[1]);
			A = new ArrayList [V+1];
			visited = new boolean [V+1];
			check = new int [V+1];
			isEven = true;
			for(int i=1; i<=V; i++) {
				A[i] = new ArrayList<Integer>();
			}

			for(int i=0; i<E; i++) {
				s = br.readLine().split(" ");
				int start = Integer.parseInt(s[0]);
				int end = Integer.parseInt(s[1]);
				A[start].add(end);
				A[end].add(start);
			}

			// 주어진 그래프가 1개로 연결돼 있다는 보장이 없으므로 모든 노드에서 수행하기
			for(int i=1; i<=V; i++) {
				if(isEven) {
					dfs(i);
				} else {
					break;
				}
			}

			if(isEven) {
				System.out.println("YES");
			} else {
				System.out.println("NO");
			}
		}
	}

	private static void dfs(int node) {		// DFS 구현하기
		visited[node] = true;
		for(int i : A[node]) {
			if(!visited[i]) {
				// 인접한 노드는 같은 집합이 아니므로 이전 노드와 다른 집합으로 처리하기
				check[i] = (check[node] + 1) % 2;
				dfs(i);
			}

			// 이미 방문한 노드가 현재 내 노드와 같은 집합이면 이분 그래프가 아님
			else if (check[node] == check[i]) {
				isEven = false;
			}
		}
	}
}
```
