# 문제 042. 소수 & 팰린드롬 수 중에서 최솟값 찾기

![문제042](./img/문제042_소수&팰린드롬수중에서최솟값찾기.png)

### 내가 작성한 풀이

```java
메모리 119860KB, 시간 804ms

public class P1747_소수팰린드롬 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();

		boolean[] prime = new boolean [10000001];   // -> 아래 추가 내용 참고
		for(int i=2; i<prime.length; i++) {
			prime[i] = true;
		}

		for(int i=2; i<prime.length; i++) {
			// 소수가 아니라면 pass
			if(!prime[i]) {
				continue;
			}

			// 배수 구하기
			for(int j=2; j<prime.length; j++) {
				if(i*j >= prime.length) {
					break;
				}

				prime[i*j] = false;
			}

			// N보다 크거나 같은 소수라면 팰린드롬 수인지 확인
			if(i >= N && isPalindrom(i)) {
				System.out.println(i);
				break;
			}
		}
	}

    /**
     * 팰린드롬 수 판별
     */
	private static boolean isPalindrom(int num) {
		String[] strArr = String.valueOf(num).split("");
		int left = 0;
		int right = strArr.length-1;

		while(left < right) {
			if(!strArr[left].equals(strArr[right])) {
				return false;
			}

			left++;
			right--;
		}

		return true;
	}
}
```

**추가 내용**

문제에서 최솟값 N만 주어지고, 최댓값이 주어지지 않기 때문에 소수 판별 배열의 크기를 어떻게 설정해야 할 지 어려움을 겪었다.  
그래서 처음에는 `boolean[] prime = new boolean [1000000000];`로 설정해서 메모리 초과가 발생했고, 이후 문제집 풀이의 배열 크기를 참고하여 `boolean[] prime = new boolean [10000001];`로 크기를 줄여서 문제를 해결했다.  
N이 최대 1,000,000이기 때문에 최소의 소수 팰린드롬은 항상 10,030,01 이하에서 나온다. 따라서 배열의 크기를 보통 10,000,001로 설정할 수 있다.

### 문제집 풀이

```java
메모리 61740KB, 시간 428ms

public class P1747_소수팰린드롬 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();

		int[] A = new int [10000001];		// N의 범위까지 소수 구하기
		for(int i=2; i<A.length; i++) {
			A[i] = i;
		}

		for(int i=2; i<Math.sqrt(A.length); i++) {		// 제곱근까지만 수행하기
			if(A[i] == 0) {
				continue;
			}

			for(int j=i+i; j<A.length; j=j+i) {		// 배수 지우기
				A[j] = 0;
			}
		}

		int i = N;
		while(true) {		// N부터 1씩 증가시키면서 소수와 펠린드롬 수가 맞는지 확인
			if(A[i] != 0) {
				int result = A[i];

				if(isPalindrome(result)) {
					System.out.println(result);
					break;
				}
			}

			i++;
		}
	}

	private static boolean isPalindrome(int target) {		// 팰린드롬 수 판별 함수
		char[] temp = String.valueOf(target).toCharArray();
		int s = 0;
		int e = temp.length - 1;

		while(s < e) {
			if(temp[s] != temp[e]) {
				return false;
			}

			s++;
			e--;
		}

		return true;
	}
}
```
